---
layout: post
lang: pt
title: Lidando com Named Pipes em Malwares
author: estr3llas
author_nickname: estr3llas
banner: lidando_com_named.png
description: "Uma breve introdu√ß√£o sobre como malwares utilizam desse mecanismo de IPC do sistema Windows."
tags: [malware, reverse engineering]
---

Um dos principais mecanismos de realizar-se uma comunica√ß√£o entre processos (IPC) no Windows √© atrav√©s da **mem√≥ria compartilhada entre esses processos**.

Sabendo disso, _pipes_ s√£o nada mais que um range de mem√≥ria compartilhada tratadas como **objeto de arquivo**. Ent√£o, como s√£o tratados como arquivos, podemos utilizar fun√ß√µes comuns destinadas a arquivos da _Windows API_ como forma de intera√ß√£o para com esses _pipes_.

> _Podemos ler um pipe com a API `ReadFile()`, ou escrever no mesmo com a API `WriteFile()`._

<br>

O modelo utilizado por _pipes_ para manusear essas estruturas de dados √© o **FIFO** (_First in First out_), ou seja, o primeiro _byte_ escrito no _pipe_ ser√° o primeiro a ser lido nesse _pipe_, e, ap√≥s ser lido, esse _byte_ ficar√° **indispon√≠vel** para ser lido de novo.

> _No entanto, a API `PeekNamedPipe()` contorna essa situa√ß√£o lendo dados de um pipe **sem** remov√™-los._

<br>

Existem dois principais tipos de _pipes_: **_Named pipes_** e **_Anonymous pipes_**. A diferen√ßa entre eles √© que um recebe um nome, e o outro n√£o.

<br>

Neste artigo, vamos focar principalmente nos _named pipes_, por√©m alguns conceitos explicados aqui tamb√©m servem para _anonymous pipes_.

Um _named pipe_ funciona atrav√©s de um modelo `client-server`, onde h√° o _named pipe_ servidor e diversos _named pipes_ clientes. Todas as inst√¢ncias de um _named pipe_ espec√≠fico **devem compartilhar o mesmo nome**, por√©m cada inst√¢ncia tem seu pr√≥prio _buffer_, _handle_ e canal de comunica√ß√£o.

<br>

### Agora, como √© feita a comunica√ß√£o entre esses pipes?

Sabendo que esse mecanismos utiliza do modelo `client-server`, _named pipes_ podem adotar duas formas de comunica√ß√£o: _half-duplex_ (HDX) ou _full-duplex_ (FDX). No HDX, o cliente abre um canal onde pode escrever dados no servidor, sem resposta do servidor. J√° no FDX, um canal de duas-m√£os √© aberto, possibilitando a escrita de ambos os lados.

<br>

Quando se trata de **processos**, qualquer processo pode acessar um _named pipe_, podendo agir tanto como servidor quanto cliente. A partir disso, a comunica√ß√£o `peer-to-peer` se torna poss√≠vel.  O termo "_server_" de um _named pipe_, refere-se ao processo que **o criou**, enquanto o termo "_client_", refere-se ao **processo conectado ao processo servidor**.

> _Named pipes, al√©m de possibilitarem a IPC entre processos locais, tamb√©m permitem **a comunica√ß√£o entre processos de hosts remotos**. Quando um processo servidor est√° rodando, todos seus named pipes s√£o acess√≠veis remotamente tamb√©m._

<br>

Para o processo servidor **criar** um _named pipe_, utiliza-se a _API_ `CreateNamedPipe()`, e para aceitar uma conex√£o do processo cliente, usa-se a _API_ `ConnectNamedPipe()`. J√° pelo _client side_, nos conectamos a um _named pipe_ com as _APIs_ `CreateFile()` ou `CallNamedPipe()`.

> _Podemos verificar as permiss√µes de um named pipe em espec√≠fico com a ferramenta accesschk.exe do conjunto Sysinternals, passando "pipe" como primeiro argumento - `accesschk.exe pipe`._

<img src="/assets/img/pipe-malware/named_pipe_diagram.png">

---

_Named pipes_ tamb√©m possibilitam serem utilizados de forma **maliciosa** por atacantes. Um atacante pode usar desse mecanismo para movimento lateral em um host j√° comprometido, escalar seus privil√©gios e at√© mesmo em malwares, tonando-os uma **stream de dados alternativa**.

Temos como exemplo o ransomware **NotPetya** (_ou Petrwrap_) onde um de seus TTPs, o roubo de credenciais, era feito atrav√©s de _named pipes_.

<br>

### NotPetya Ransomware:

O ransomware _NotPetya_ comunicava-se via _named pipes_ com o m√≥dulo de roubo de credenciais do sistema da v√≠tima.

Esse _named pipe_ era criado a partir de um _GUID_ aleat√≥rio. Onde o m√≥dulo de roubo de credenciais era lan√ßado como um _child process_ dessa _GUID_, **levando o named pipe como argumento**.

<img src="/assets/img/pipe-malware/notpetya.png">

Uma vez que carregado, o m√≥dulo de roubo de credenciais faz uma chamada a _API_ `OpenProcess()` no `lsass.exe` com a flag de acesso configurado em _VM_READ_, ent√£o, procura pelo m√≥dulos `wdigest.dll` e `lsasrv.dll`, ambos usados para autentica√ß√£o de usu√°rios no sistema.

<br>

Concluindo, o m√≥dulo extrai credenciais do **LSASS** (Igualmente ao _Mimikatz_) e as envia ao processo do malware _NotPetya_ atrav√©s de um _named pipe_.

---

Agora que temos uma pequena no√ß√£o sobre como os _named pipes_ funcionam, e como podem ser implementados em tarefas maliciosas, vamos aplicar esse conhecimento.

> _Disclaimer: A sample em quest√£o trata-se de um script malicioso em powershell **severamente ofuscado**, do qual o processo de desofusca√ß√£o **n√£o** pertence ao escopo do artigo. Dito isso, partiremos para a an√°lise do shellcode j√° desofuscado e o uso dos named pipes no mesmo._

<br>

Ao chegarmos no _shellcode_ desofuscado, encontramos o seguinte:

<img src="/assets/img/pipe-malware/pipe_cyberchef.png">

Podemos dumpar esse _shellcode_ com a op√ß√£o "_Save output to file_", do pr√≥prio [_cyberchef_](https://cyberchef.org/).

Ao abrir o bin√°rio no [DiE](https://github.com/horsicq/Detect-It-Easy), n√£o encontramos nenhuma informa√ß√£o √∫til. Afinal, trata-se de um _shellcode_.

<img src="/assets/img/pipe-malware/pipe_die.png">

Nossa op√ß√£o agora √©: **injetar esse _shellcode_ em algum processo**. A inje√ß√£o deve ser feita em um bin√°rio qualquer de 32-bits, j√° que o _shellcode_ √© feito na arquitetura 32-bits.
# Inje√ß√£o do shellcode:

> _A t√©cnica a seguir pode ser usada n√£o somente para injetar shellcodes/payloads, mas qualquer inje√ß√£o em geral._

Come√ßamos abrindo um processo de 32-bits qualquer no [x64dbg](https://x64dbg.com/). Ap√≥s aberto, precisamos primeiro **alocar mem√≥ria para esse _shellcode_**, s√≥ ent√£o prosseguir com a inje√ß√£o propriamente dita.  A Aloca√ß√£o de mem√≥ria se d√° ao acessar a aba "**_Memory Map_**", clicando com o bot√£o direito, selecionando a op√ß√£o "**_Allocate Memory_**" e podemos deixar o valor padr√£o, j√° √© o suficiente.

<img src="/assets/img/pipe-malware/pipe_allocate.png">

Ap√≥s alocada, precisamos **preencher** essa mem√≥ria com o _shellcode_. Abrimos o _shellcode_ em algum **editor hexadecimal** de sua prefer√™ncia, selecionamos todos seus _bytes_ e os copiamos.

<img src="/assets/img/pipe-malware/pipe_copy_bytes.png">

> _Na imagem utilizo um editor que gosto bastante: o ImHex, desenvolvido pelo @WerWolv. [WerWolv/ImHex: üîç A Hex Editor for Reverse Engineers, Programmers and people who value their retinas when working at 3 AM. (github.com)](https://github.com/WerWolv/ImHex)_

<br>

Ent√£o, com esses _bytes_ copiados, basta col√°-los no nosso _debugger_.

Clicamos com o bot√£o direito no **primeito _byte_ no _dump_ da mem√≥ria rec√©m alocada**, selecionamos "_Binary_", ent√£o: _Paste (Ignore Size)_.

<img src="/assets/img/pipe-malware/pipe_paste_bytes.png">

Feito isso, teremos o seguinte resultado:

<img src="/assets/img/pipe-malware/pipe_dump_paste.png">

O pr√≥ximo passo √© a **visualiza√ß√£o** desse conte√∫do em instru√ß√µes. Clicamos com o bot√£o direito nesses _bytes_ e **seguimos no _disassemble_**.

<img src="/assets/img/pipe-malware/pipe_dump_asm.png">

E por √∫ltimo, afim de come√ßarmos a **debuggar** esse _shellcode_, precisamos **setar uma nova origem para (EIP) a primeira instru√ß√£o do _shellcode_**. Para isso: bot√£o direito no _disassemble_, selecione "_Set New Origin Here_".

<img src="/assets/img/pipe-malware/pipe_origin_asm.png">

Caso tudo d√™ certo, agora estaremos aptos a iniciar o processo de _debugging/reversing_ desse _shellcode_.

---
# Debugging/Reversing

> _Geralmente, em shellcodes, vamos encontrar **muitas opera√ß√µes matem√°ticas** e **desvios de fluxos repentinos**, tenha isso em mente. A ideia aqui √© entender quais **syscalls** s√£o feitas pelo bin√°rio._

<br>

Logo de √≠nicio, descendo um pouco o _disassemble_, vemos um **desvio de fluxo** bastante interessante, h√° um `jmp eax`. Ent√£o vale a pena colocar um _breakpoint_ nessa instru√ß√£o.

<img src="/assets/img/pipe-malware/pipe_jmp_eax.png">

Aperte **F9 (Run)**. Ao chegarmos nesse _breakpoint_, percebemos que a instru√ß√£o `jmp eax`, na verdade, √© uma chamada para a _API_ `VirtualAlloc()`.

<img src="/assets/img/pipe-malware/pipe_eax_virtualalloc.png">

Checando os argumentos passados a _API_, vemos que:

<img src="/assets/img/pipe-malware/pipe_vialloc_stack.png">

√â feita uma aloca√ß√£o de mem√≥ria do tipo `MEM_COMMIT`, com 0x0007FFFF (524287) _bytes_ de tamanho.

Estendendo a an√°lise, percebemos que todo esse algoritmo trata-se de um **loop**, onde s√£o passadas diversas _APIs_ a esse `jmp eax`. Ent√£o vamos continuando a execu√ß√£o at√© parar na instru√ß√£o `jmp eax` de novo.

<br>

O segundo hit do breakpoint j√° fica **interessant√≠ssimo**, √© uma chamada a API `CreateNamedPipe()`, tema principal deste artigo.

## O named pipe:

Vendo os argumento passados √† _API_, encontramos o nome do _named pipe_ criado pelo _shellcode_, sendo ele:  `\\\\.\\pipe\\status_b5ba`.

> _Para verificarmos a exist√™ncia desse named pipe, poedmos acessar a aba **handles**, **refresh** e procuramos pelo nome do named pipe._

<img src="/assets/img/pipe-malware/pipe_handle.png">

> _Perceba tamb√©m que o "tipo" do named pipe est√° como um **arquivo**, assim como dito no come√ßo deste artigo._

O terceiro hit no _breakpoint_ da instru√ß√£o `jmp eax`, √© a `ConnectNamedPipe()`. _API_ essa que habilita um _named pipe_ no processo servidor a receber conex√µes de _named pipes_ clientes. Podemos confirmar isso **verificando os par√¢metros** passados a essa _API_, sendo o _handle_ setado para `1A8`, justamente o _handle_ do _named pipe_ criado.

<img src="/assets/img/pipe-malware/pipe_connect_stack.png">

Por√©m agora temos um problema. Ap√≥s essa chamada, n√£o temos mais hits no nosso _breakpoint_, o c√≥digo permanece **rodando eternamente**.

De acordo com a documenta√ß√£o da _Microsoft_, caso o par√¢metro `hNamedPipe` da _API_ `ConnectNamedPipe()` **n√£o** for aberto com a flag `FILE_FLAG_OVERLAPPED` (O que √© o nosso caso), a fun√ß√£o **n√£o retornar√° at√© receber uma conex√£o ou um erro ocorrer**.

<br>

Sabendo disso, podemos **inferir** que o _shellcode_ est√° esperando uma conex√£o no _named pipe_ que o mesmo criou. E como prosseguimos a an√°lise? Simples! Nos **conectamos** a esse _named pipe_!
# Conex√£o:

O intuito agora √© nos conectarmos a esse _named pipe_ atrav√©s da fun√ß√£o `CallNamedPipeA()`. Para realizarmos essa conex√£o um simples c√≥digo em C ser√° o suficiente.

```c
#include <windows.h>

int main (void) {

	CallNamedPipeA(
		"\\\\.\\pipe\\status_b5ba", //lpNamedPipeName
		(LPVOID)"ABCDEFGH",         //lpInBuffer
		8,                          //nInBufferSize
		NULL,                       //lpOutBuffer
		0,                          //nOutBufferSize
		NULL,                       //lpBytesRead
		NMPWAIT_NOWAIT              //nTimeOut
	);

	return 0;
}
```

> _N√£o esque√ßa de rodar o programa com os **mesmos n√≠veis de privil√©gios** que o shellcode congelado no debugger_.

# Leitura:

Ap√≥s a conex√£o ser feita, vemos que o _shellcode_ resume sua execu√ß√£o, hitando novamente o breakpoint na instru√ß√£o `jmp eax`, mas dessa vez, chamando a _API_ `ReadFile()` (_Utilizada tamb√©m para ler o conte√∫do desse named pipe, como dito anteriormente_).

<br>

A `ReadFile()`, por sua vez, l√™ os **0004** primeiros _bytes_ do _buffer_ desse _named pipe_ no endere√ßo `0x00FFFAE0`, podemos confirmar essa leitura seguindo esse endere√ßo no _dump_.

## Antes da chamada:

<img src="/assets/img/pipe-malware/pipe_before_call.png">

## Depois da chamada:

<img src="/assets/img/pipe-malware/pipe_after_Call.png">

Ap√≥s essa chamada, outra √© feita na mesma _API_, por√©m dessa vez lendo _2000 bytes_.

> _Dessa forma, podemos entender que a primeira chamada a `ReadFile()` serve apenas como uma verifica√ß√£o._

<br>

Confirmamos isso olhando para o par√¢metro `nNumberOfBytesToRead` da _API_.

<img src="/assets/img/pipe-malware/pipe_readfl_stack.png">

Por√©m, essa chamada serve para **ler o resto do _buffer_ contido no _named pipe_**. Ao verificarmos no _dump_ desse endere√ßo, encontramos o resto do nosso _buffer_.

<img src="/assets/img/pipe-malware/pipe_readfl_dump.png">

> _Uma terceira chamada a essa API √© realizada, lendo mais 2000 bytes._

# Uso do Buffer:

Agora precisamos entender como √© utilizado esse _buffer_. Para isso utilizaremos _hardwares breakpoints_ no **acesso** (escrita ou leitura) desses _bytes_ vindo de qualquer fonte externa.

> Para setar _hardware breakpoints_: bot√£o direito no primeiro _byte_ do _dump_, _breakpoint_, _hardware, access_, _byte_.

<img src="/assets/img/pipe-malware/pipe_hardware_bp.png">

Ao hitar nosso _breakpoint_, percebemos que [esp+8] √© movido a `ecx`, caracterizando um acesso a esse endere√ßo. Olhando o _disassemble_ desse _breakpoint_, vemos que: caso `ecx` for igual a `eax`, ocorre um `jmp` para [esp+10].

<img src="/assets/img/pipe-malware/pipe_mal_asm.png">

<img src="/assets/img/pipe-malware/pipe_eax_ecx.png">

>_[esp+10], por sua vez, refere-se a "segunda metade" do buffer armazenado pelo named pipe._

<br>

Ent√£o, caso `ecx` (ABCD em _LE_) for igual ao tamanho do par√¢metro passado em `nInBufferSize` (_0004_ em _LE_), o `jmp` ocorreria para [esp+10] ("_EFGH_" (_segunda metade do shellcode_)), executando qualquer coisa que estiver nesse endere√ßo.

## Exemplo:

```c
#include <windows.h>

int main (void) {

	unsigned char shellcode[] = "\x04\x00\x00\x00\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80..." //exemplo

	CallNamedPipeA(
		"\\\\.\\pipe\\status_b5ba", //lpNamedPipeName
		(LPVOID)shellcode,          //lpInBuffer
		4000,                       //nInBufferSize
		NULL,                       //lpOutBuffer
		0,                          //nOutBufferSize
		NULL,                       //lpBytesRead
		NMPWAIT_NOWAIT              //nTimeOut
	);

	return 0;
}
```

Onde, seriam comparados os primeiros `\x04\x00\x00\x00` (`nInBufferSize`) e, caso fossem iguais, executaria o c√≥digo contido a partir de `\x6e\x2f\x73\x68...`.
# Conclus√£o

Conclu√≠mos que: O bin√°rio inicial (_shellcode_) realiza uma **inje√ß√£o de c√≥digo atrav√©s do buffer de um _named pipe_**. Esperando que o tamanho do _shellcode_ seja definido nos primeiros par√¢metro `nInBufferSize`. Sendo assim, o trabalho √© distribu√≠do entre dois bin√°rios, um injetando o c√≥digo, e o outro guardando o c√≥digo a ser injetado.

---

E √© isso por enquanto pessoal, espero que tenham gostado. Uma √≥tima semana!

<img src="/assets/img/pipe-malware/pipe_tonton.gif">

# Leitura Complementar:

<a href="https://securityintelligence.com/identifying-named-pipe-impersonation-and-other-malicious-privilege-escalation-techniques/">Identifying Named Pipe Impersonation and Other Malicious Privilege Escalation Techniques (securityintelligence.com)</a>

<a href="https://medium.com/falconforce/falconfriday-suspicious-named-pipe-events-0xff1b-fe475d7ebd8">FalconFriday ‚Äî Suspicious named pipe events ‚Äî 0xFF1B | by Olaf Hartong | FalconForce | Medium</a>